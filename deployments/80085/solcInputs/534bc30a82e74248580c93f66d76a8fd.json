{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "src/BookViewer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IBookManager} from \"v2-core/interfaces/IBookManager.sol\";\nimport {SignificantBit} from \"v2-core/libraries/SignificantBit.sol\";\nimport {Math} from \"v2-core/libraries/Math.sol\";\nimport {Lockers} from \"v2-core/libraries/Lockers.sol\";\nimport {BookId} from \"v2-core/libraries/BookId.sol\";\nimport {Tick, TickLibrary} from \"v2-core/libraries/Tick.sol\";\nimport {FeePolicy, FeePolicyLibrary} from \"v2-core/libraries/FeePolicy.sol\";\n\nimport {IBookViewer} from \"./interfaces/IBookViewer.sol\";\nimport {IController} from \"./interfaces/IController.sol\";\n\ncontract BookViewer is IBookViewer {\n    using SafeCast for *;\n    using TickLibrary for *;\n    using Math for uint256;\n    using SignificantBit for uint256;\n    using FeePolicyLibrary for FeePolicy;\n\n    IBookManager public immutable bookManager;\n\n    constructor(IBookManager bookManager_) {\n        bookManager = bookManager_;\n    }\n\n    function getLiquidity(BookId id, Tick tick, uint256 n) external view returns (Liquidity[] memory liquidity) {\n        liquidity = new Liquidity[](n);\n        if (bookManager.getDepth(id, tick) == 0) tick = bookManager.maxLessThan(id, tick);\n        uint256 i;\n        while (i < n) {\n            if (Tick.unwrap(tick) == type(int24).min) break;\n            liquidity[i] = Liquidity({tick: tick, depth: bookManager.getDepth(id, tick)});\n            tick = bookManager.maxLessThan(id, tick);\n            unchecked {\n                ++i;\n            }\n        }\n        assembly {\n            mstore(liquidity, i)\n        }\n    }\n\n    function getExpectedInput(IController.TakeOrderParams memory params)\n        external\n        view\n        returns (uint256 takenQuoteAmount, uint256 spentBaseAmount)\n    {\n        IBookManager.BookKey memory key = bookManager.getBookKey(params.id);\n\n        if (bookManager.isEmpty(params.id)) return (0, 0);\n\n        Tick tick = bookManager.getHighest(params.id);\n\n        while (Tick.unwrap(tick) > type(int24).min) {\n            unchecked {\n                if (params.limitPrice > tick.toPrice()) break;\n                uint256 maxAmount;\n                if (key.takerPolicy.usesQuote()) {\n                    maxAmount = key.takerPolicy.calculateOriginalAmount(params.quoteAmount - takenQuoteAmount, true);\n                } else {\n                    maxAmount = params.quoteAmount - takenQuoteAmount;\n                }\n                maxAmount = maxAmount.divide(key.unitSize, true);\n\n                if (maxAmount == 0) break;\n                uint256 currentDepth = bookManager.getDepth(params.id, tick);\n                uint256 quoteAmount = (currentDepth > maxAmount ? maxAmount : currentDepth) * key.unitSize;\n                uint256 baseAmount = tick.quoteToBase(quoteAmount, true);\n                if (key.takerPolicy.usesQuote()) {\n                    quoteAmount = uint256(int256(quoteAmount) - key.takerPolicy.calculateFee(quoteAmount, false));\n                } else {\n                    baseAmount = uint256(baseAmount.toInt256() + key.takerPolicy.calculateFee(baseAmount, false));\n                }\n                if (quoteAmount == 0) break;\n\n                takenQuoteAmount += quoteAmount;\n                spentBaseAmount += baseAmount;\n                if (params.quoteAmount <= takenQuoteAmount) break;\n                tick = bookManager.maxLessThan(params.id, tick);\n            }\n        }\n    }\n\n    function getExpectedOutput(IController.SpendOrderParams memory params)\n        external\n        view\n        returns (uint256 takenQuoteAmount, uint256 spentBaseAmount)\n    {\n        IBookManager.BookKey memory key = bookManager.getBookKey(params.id);\n\n        if (bookManager.isEmpty(params.id)) return (0, 0);\n\n        Tick tick = bookManager.getHighest(params.id);\n\n        unchecked {\n            while (spentBaseAmount <= params.baseAmount && Tick.unwrap(tick) > type(int24).min) {\n                if (params.limitPrice > tick.toPrice()) break;\n                uint256 maxAmount;\n                if (key.takerPolicy.usesQuote()) {\n                    maxAmount = params.baseAmount - spentBaseAmount;\n                } else {\n                    maxAmount = key.takerPolicy.calculateOriginalAmount(params.baseAmount - spentBaseAmount, false);\n                }\n                maxAmount = tick.baseToQuote(maxAmount, false) / key.unitSize;\n\n                if (maxAmount == 0) break;\n                uint256 currentDepth = bookManager.getDepth(params.id, tick);\n                uint256 quoteAmount = (currentDepth > maxAmount ? maxAmount : currentDepth) * key.unitSize;\n                uint256 baseAmount = tick.quoteToBase(quoteAmount, true);\n                if (key.takerPolicy.usesQuote()) {\n                    quoteAmount = uint256(int256(quoteAmount) - key.takerPolicy.calculateFee(quoteAmount, false));\n                } else {\n                    baseAmount = uint256(baseAmount.toInt256() + key.takerPolicy.calculateFee(baseAmount, false));\n                }\n                if (baseAmount == 0) break;\n\n                takenQuoteAmount += quoteAmount;\n                spentBaseAmount += baseAmount;\n                tick = bookManager.maxLessThan(params.id, tick);\n            }\n        }\n    }\n}\n"
    },
    "src/Controller.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ILocker} from \"v2-core/interfaces/ILocker.sol\";\nimport {IBookManager} from \"v2-core/interfaces/IBookManager.sol\";\nimport {IERC721Permit} from \"v2-core/interfaces/IERC721Permit.sol\";\nimport {Math} from \"v2-core/libraries/Math.sol\";\nimport {BookId, BookIdLibrary} from \"v2-core/libraries/BookId.sol\";\nimport {OrderId, OrderIdLibrary} from \"v2-core/libraries/OrderId.sol\";\nimport {Currency, CurrencyLibrary} from \"v2-core/libraries/Currency.sol\";\nimport {FeePolicy, FeePolicyLibrary} from \"v2-core/libraries/FeePolicy.sol\";\nimport {Tick, TickLibrary} from \"v2-core/libraries/Tick.sol\";\nimport {OrderId, OrderIdLibrary} from \"v2-core/libraries/OrderId.sol\";\n\nimport {IController} from \"./interfaces/IController.sol\";\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\ncontract Controller is IController, ILocker, ReentrancyGuard {\n    using TickLibrary for *;\n    using OrderIdLibrary for OrderId;\n    using BookIdLibrary for IBookManager.BookKey;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using Math for uint256;\n    using CurrencyLibrary for Currency;\n    using FeePolicyLibrary for FeePolicy;\n\n    IBookManager private immutable _bookManager;\n\n    constructor(address bookManager) {\n        _bookManager = IBookManager(bookManager);\n    }\n\n    modifier checkDeadline(uint64 deadline) {\n        if (block.timestamp > deadline) revert Deadline();\n        _;\n    }\n\n    modifier permitERC20(ERC20PermitParams[] calldata permitParamsList) {\n        _permitERC20(permitParamsList);\n        _;\n    }\n\n    function getDepth(BookId id, Tick tick) external view returns (uint256) {\n        return uint256(_bookManager.getDepth(id, tick)) * _bookManager.getBookKey(id).unitSize;\n    }\n\n    function getHighestPrice(BookId id) external view returns (uint256) {\n        return _bookManager.getHighest(id).toPrice();\n    }\n\n    function getOrder(OrderId orderId)\n        external\n        view\n        returns (address provider, uint256 price, uint256 openAmount, uint256 claimableAmount)\n    {\n        (BookId bookId, Tick tick,) = orderId.decode();\n        IBookManager.BookKey memory key = _bookManager.getBookKey(bookId);\n        uint256 unitSize = key.unitSize;\n        price = tick.toPrice();\n        IBookManager.OrderInfo memory orderInfo = _bookManager.getOrder(orderId);\n        provider = orderInfo.provider;\n        openAmount = unitSize * orderInfo.open;\n        FeePolicy makerPolicy = key.makerPolicy;\n        claimableAmount = tick.quoteToBase(unitSize * orderInfo.claimable, false);\n        if (!makerPolicy.usesQuote()) {\n            int256 fee = makerPolicy.calculateFee(claimableAmount, false);\n            claimableAmount = fee > 0 ? claimableAmount - uint256(fee) : claimableAmount + uint256(-fee);\n        }\n    }\n\n    function fromPrice(uint256 price) external pure returns (Tick) {\n        return price.fromPrice();\n    }\n\n    function toPrice(Tick tick) external pure returns (uint256) {\n        return tick.toPrice();\n    }\n\n    function lockAcquired(address sender, bytes memory data) external nonReentrant returns (bytes memory returnData) {\n        if (msg.sender != address(_bookManager) || sender != address(this)) revert InvalidAccess();\n        (address user, Action[] memory actionList, bytes[] memory orderParamsList, address[] memory tokensToSettle) =\n            abi.decode(data, (address, Action[], bytes[], address[]));\n\n        uint256 length = actionList.length;\n        OrderId[] memory ids = new OrderId[](length);\n        uint256 orderIdIndex;\n\n        for (uint256 i = 0; i < length; ++i) {\n            Action action = actionList[i];\n            if (action == Action.OPEN) {\n                _open(abi.decode(orderParamsList[i], (OpenBookParams)));\n            } else if (action == Action.MAKE) {\n                OrderId id = _make(abi.decode(orderParamsList[i], (MakeOrderParams)));\n                if (OrderId.unwrap(id) != 0) {\n                    _bookManager.transferFrom(address(this), user, OrderId.unwrap(id));\n                    ids[orderIdIndex++] = id;\n                }\n            } else if (action == Action.LIMIT) {\n                OrderId id = _limit(abi.decode(orderParamsList[i], (LimitOrderParams)));\n                if (OrderId.unwrap(id) != 0) {\n                    _bookManager.transferFrom(address(this), user, OrderId.unwrap(id));\n                    ids[orderIdIndex++] = id;\n                }\n            } else if (action == Action.TAKE) {\n                _take(abi.decode(orderParamsList[i], (TakeOrderParams)));\n            } else if (action == Action.SPEND) {\n                _spend(abi.decode(orderParamsList[i], (SpendOrderParams)));\n            } else if (action == Action.CLAIM) {\n                ClaimOrderParams memory claimOrderParams = abi.decode(orderParamsList[i], (ClaimOrderParams));\n                uint256 orderId = OrderId.unwrap(claimOrderParams.id);\n                _bookManager.checkAuthorized(_bookManager.ownerOf(orderId), user, orderId);\n                _claim(claimOrderParams);\n            } else if (action == Action.CANCEL) {\n                CancelOrderParams memory cancelOrderParams = abi.decode(orderParamsList[i], (CancelOrderParams));\n                uint256 orderId = OrderId.unwrap(cancelOrderParams.id);\n                _bookManager.checkAuthorized(_bookManager.ownerOf(orderId), user, orderId);\n                _cancel(cancelOrderParams);\n            } else {\n                revert InvalidAction();\n            }\n        }\n\n        _settleTokens(user, tokensToSettle);\n\n        assembly {\n            mstore(ids, orderIdIndex)\n        }\n        returnData = abi.encode(ids);\n    }\n\n    function execute(\n        Action[] calldata actionList,\n        bytes[] calldata paramsDataList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata erc20PermitParamsList,\n        ERC721PermitParams[] calldata erc721PermitParamsList,\n        uint64 deadline\n    ) external payable checkDeadline(deadline) returns (OrderId[] memory ids) {\n        if (actionList.length != paramsDataList.length) revert InvalidLength();\n        _permitERC20(erc20PermitParamsList);\n        _permitERC721(erc721PermitParamsList);\n\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        bytes memory result = _bookManager.lock(address(this), lockData);\n\n        if (result.length != 0) {\n            (ids) = abi.decode(result, (OrderId[]));\n        }\n        return ids;\n    }\n\n    function open(OpenBookParams[] calldata openBookParamsList, uint64 deadline) external checkDeadline(deadline) {\n        uint256 length = openBookParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.OPEN;\n            paramsDataList[i] = abi.encode(openBookParamsList[i]);\n        }\n        address[] memory tokensToSettle;\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        _bookManager.lock(address(this), lockData);\n    }\n\n    function limit(\n        LimitOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable checkDeadline(deadline) permitERC20(permitParamsList) returns (OrderId[] memory ids) {\n        uint256 length = orderParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.LIMIT;\n            paramsDataList[i] = abi.encode(orderParamsList[i]);\n        }\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        bytes memory result = _bookManager.lock(address(this), lockData);\n        (ids) = abi.decode(result, (OrderId[]));\n    }\n\n    function make(\n        MakeOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable checkDeadline(deadline) permitERC20(permitParamsList) returns (OrderId[] memory ids) {\n        uint256 length = orderParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.MAKE;\n            paramsDataList[i] = abi.encode(orderParamsList[i]);\n        }\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        bytes memory result = _bookManager.lock(address(this), lockData);\n        (ids) = abi.decode(result, (OrderId[]));\n    }\n\n    function take(\n        TakeOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable checkDeadline(deadline) permitERC20(permitParamsList) {\n        uint256 length = orderParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.TAKE;\n            paramsDataList[i] = abi.encode(orderParamsList[i]);\n        }\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        _bookManager.lock(address(this), lockData);\n    }\n\n    function spend(\n        SpendOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable checkDeadline(deadline) permitERC20(permitParamsList) {\n        uint256 length = orderParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.SPEND;\n            paramsDataList[i] = abi.encode(orderParamsList[i]);\n        }\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        _bookManager.lock(address(this), lockData);\n    }\n\n    function claim(\n        ClaimOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC721PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external checkDeadline(deadline) {\n        _permitERC721(permitParamsList);\n        uint256 length = orderParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.CLAIM;\n            paramsDataList[i] = abi.encode(orderParamsList[i]);\n        }\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        _bookManager.lock(address(this), lockData);\n    }\n\n    function cancel(\n        CancelOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC721PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external checkDeadline(deadline) {\n        _permitERC721(permitParamsList);\n        uint256 length = orderParamsList.length;\n        Action[] memory actionList = new Action[](length);\n        bytes[] memory paramsDataList = new bytes[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            actionList[i] = Action.CANCEL;\n            paramsDataList[i] = abi.encode(orderParamsList[i]);\n        }\n        bytes memory lockData = abi.encode(msg.sender, actionList, paramsDataList, tokensToSettle);\n        _bookManager.lock(address(this), lockData);\n    }\n\n    function _open(OpenBookParams memory params) internal {\n        _bookManager.open(params.key, params.hookData);\n    }\n\n    function _make(MakeOrderParams memory params) internal returns (OrderId id) {\n        IBookManager.BookKey memory key = _bookManager.getBookKey(params.id);\n\n        uint256 quoteAmount = params.quoteAmount;\n        if (key.makerPolicy.usesQuote()) {\n            quoteAmount = key.makerPolicy.calculateOriginalAmount(quoteAmount, false);\n        }\n        uint64 unit = (quoteAmount / key.unitSize).toUint64();\n        if (unit > 0) {\n            (id,) = _bookManager.make(\n                IBookManager.MakeParams({key: key, tick: params.tick, unit: unit, provider: address(0)}),\n                params.hookData\n            );\n        }\n        return id;\n    }\n\n    function _limit(LimitOrderParams memory params) internal returns (OrderId id) {\n        (, uint256 spentBaseAmount) = _spend(\n            SpendOrderParams({\n                id: params.takeBookId,\n                limitPrice: params.limitPrice,\n                baseAmount: params.quoteAmount,\n                minQuoteAmount: 0,\n                hookData: params.takeHookData\n            })\n        );\n        params.quoteAmount -= spentBaseAmount;\n        if (params.quoteAmount > 0) {\n            id = _make(\n                MakeOrderParams({\n                    id: params.makeBookId,\n                    quoteAmount: params.quoteAmount,\n                    tick: params.tick,\n                    hookData: params.makeHookData\n                })\n            );\n        }\n    }\n\n    function _take(TakeOrderParams memory params)\n        internal\n        returns (uint256 takenQuoteAmount, uint256 spentBaseAmount)\n    {\n        IBookManager.BookKey memory key = _bookManager.getBookKey(params.id);\n\n        while (params.quoteAmount > takenQuoteAmount && !_bookManager.isEmpty(params.id)) {\n            Tick tick = _bookManager.getHighest(params.id);\n            if (params.limitPrice > tick.toPrice()) break;\n            uint256 maxAmount;\n            unchecked {\n                if (key.takerPolicy.usesQuote()) {\n                    maxAmount = key.takerPolicy.calculateOriginalAmount(params.quoteAmount - takenQuoteAmount, true);\n                } else {\n                    maxAmount = params.quoteAmount - takenQuoteAmount;\n                }\n            }\n            maxAmount = maxAmount.divide(key.unitSize, true);\n\n            if (maxAmount == 0) break;\n            (uint256 quoteAmount, uint256 baseAmount) = _bookManager.take(\n                IBookManager.TakeParams({key: key, tick: tick, maxUnit: maxAmount.toUint64()}), params.hookData\n            );\n            if (quoteAmount == 0) break;\n\n            takenQuoteAmount += quoteAmount;\n            spentBaseAmount += baseAmount;\n        }\n        if (params.maxBaseAmount < spentBaseAmount) revert ControllerSlippage();\n    }\n\n    function _spend(SpendOrderParams memory params)\n        internal\n        returns (uint256 takenQuoteAmount, uint256 spentBaseAmount)\n    {\n        IBookManager.BookKey memory key = _bookManager.getBookKey(params.id);\n\n        while (spentBaseAmount < params.baseAmount && !_bookManager.isEmpty(params.id)) {\n            Tick tick = _bookManager.getHighest(params.id);\n            if (params.limitPrice > tick.toPrice()) break;\n            uint256 maxAmount;\n            unchecked {\n                if (key.takerPolicy.usesQuote()) {\n                    maxAmount = params.baseAmount - spentBaseAmount;\n                } else {\n                    maxAmount = key.takerPolicy.calculateOriginalAmount(params.baseAmount - spentBaseAmount, false);\n                }\n            }\n            maxAmount = tick.baseToQuote(maxAmount, false) / key.unitSize;\n            if (maxAmount == 0) break;\n            (uint256 quoteAmount, uint256 baseAmount) = _bookManager.take(\n                IBookManager.TakeParams({key: key, tick: tick, maxUnit: maxAmount.toUint64()}), params.hookData\n            );\n            if (baseAmount == 0) break;\n            takenQuoteAmount += quoteAmount;\n            spentBaseAmount += baseAmount;\n        }\n        if (params.minQuoteAmount > takenQuoteAmount) revert ControllerSlippage();\n    }\n\n    function _claim(ClaimOrderParams memory params) internal {\n        _bookManager.claim(params.id, params.hookData);\n    }\n\n    function _cancel(CancelOrderParams memory params) internal {\n        IBookManager.BookKey memory key = _bookManager.getBookKey(params.id.getBookId());\n        try _bookManager.cancel(\n            IBookManager.CancelParams({id: params.id, toUnit: (params.leftQuoteAmount / key.unitSize).toUint64()}),\n            params.hookData\n        ) {} catch {}\n    }\n\n    function _settleTokens(address user, address[] memory tokensToSettle) internal {\n        Currency native = CurrencyLibrary.NATIVE;\n        int256 currencyDelta = _bookManager.getCurrencyDelta(address(this), native);\n        if (currencyDelta < 0) {\n            native.transfer(address(_bookManager), uint256(-currencyDelta));\n            _bookManager.settle(native);\n        }\n        currencyDelta = _bookManager.getCurrencyDelta(address(this), native);\n        if (currencyDelta > 0) {\n            _bookManager.withdraw(native, user, uint256(currencyDelta));\n        }\n\n        uint256 length = tokensToSettle.length;\n        for (uint256 i = 0; i < length; ++i) {\n            Currency currency = Currency.wrap(tokensToSettle[i]);\n            currencyDelta = _bookManager.getCurrencyDelta(address(this), currency);\n            if (currencyDelta < 0) {\n                IERC20(tokensToSettle[i]).safeTransferFrom(user, address(_bookManager), uint256(-currencyDelta));\n                _bookManager.settle(currency);\n            }\n            currencyDelta = _bookManager.getCurrencyDelta(address(this), currency);\n            if (currencyDelta > 0) {\n                _bookManager.withdraw(Currency.wrap(tokensToSettle[i]), user, uint256(currencyDelta));\n            }\n            uint256 balance = IERC20(tokensToSettle[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokensToSettle[i]).transfer(user, balance);\n            }\n        }\n        if (address(this).balance > 0) native.transfer(user, address(this).balance);\n    }\n\n    function _permitERC20(ERC20PermitParams[] calldata permitParamsList) internal {\n        for (uint256 i = 0; i < permitParamsList.length; ++i) {\n            ERC20PermitParams memory permitParams = permitParamsList[i];\n            if (permitParams.signature.deadline > 0) {\n                try IERC20Permit(permitParams.token).permit(\n                    msg.sender,\n                    address(this),\n                    permitParams.permitAmount,\n                    permitParams.signature.deadline,\n                    permitParams.signature.v,\n                    permitParams.signature.r,\n                    permitParams.signature.s\n                ) {} catch {}\n            }\n        }\n    }\n\n    function _permitERC721(ERC721PermitParams[] calldata permitParamsList) internal {\n        for (uint256 i = 0; i < permitParamsList.length; ++i) {\n            PermitSignature memory signature = permitParamsList[i].signature;\n            if (signature.deadline > 0) {\n                try IERC721Permit(address(_bookManager)).permit(\n                    address(this),\n                    permitParamsList[i].tokenId,\n                    signature.deadline,\n                    signature.v,\n                    signature.r,\n                    signature.s\n                ) {} catch {}\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/interfaces/IBookViewer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {BookId} from \"v2-core/libraries/BookId.sol\";\nimport {IBookManager} from \"v2-core/interfaces/IBookManager.sol\";\nimport {Tick} from \"v2-core/libraries/Tick.sol\";\n\nimport {IController} from \"./IController.sol\";\n\n/**\n * @title IBookViewer\n * @notice Interface for the book viewer contract\n */\ninterface IBookViewer {\n    /**\n     * @notice Returns the book manager\n     * @return The instance of the book manager\n     */\n    function bookManager() external view returns (IBookManager);\n\n    struct Liquidity {\n        Tick tick;\n        uint64 depth;\n    }\n\n    /**\n     * @notice Returns the liquidity for a specific book\n     * @param id The id of the book\n     * @param from The starting tick\n     * @param n The number of ticks to return\n     * @return liquidity An array of liquidity data\n     */\n    function getLiquidity(BookId id, Tick from, uint256 n) external view returns (Liquidity[] memory liquidity);\n\n    /**\n     * @notice Returns the expected input for a take order\n     * @param params The parameters of the take order\n     * @return takenQuoteAmount The expected taken quote amount\n     * @return spentBaseAmount The expected spend base amount\n     */\n    function getExpectedInput(IController.TakeOrderParams memory params)\n        external\n        view\n        returns (uint256 takenQuoteAmount, uint256 spentBaseAmount);\n\n    /**\n     * @notice Returns the expected output for a spend order\n     * @param params The parameters of the spend order\n     * @return takenQuoteAmount The expected taken quote amount\n     * @return spentBaseAmount The expected spend base amount\n     */\n    function getExpectedOutput(IController.SpendOrderParams memory params)\n        external\n        view\n        returns (uint256 takenQuoteAmount, uint256 spentBaseAmount);\n}\n"
    },
    "src/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OrderId} from \"v2-core/libraries/OrderId.sol\";\nimport {BookId} from \"v2-core/libraries/BookId.sol\";\nimport {Tick} from \"v2-core/libraries/Tick.sol\";\nimport {IBookManager} from \"v2-core/interfaces/IBookManager.sol\";\n\n/**\n * @title IController\n * @notice Interface for the controller contract\n */\ninterface IController {\n    // Error messages\n    error InvalidAccess();\n    error InvalidLength();\n    error Deadline();\n    error ControllerSlippage();\n    error InvalidAction();\n\n    /**\n     * @notice Enum for the different actions that can be performed\n     */\n    enum Action {\n        OPEN,\n        MAKE,\n        LIMIT,\n        TAKE,\n        SPEND,\n        CLAIM,\n        CANCEL\n    }\n\n    /**\n     * @notice Struct for the parameters of the ERC20 permit\n     */\n    struct ERC20PermitParams {\n        address token;\n        uint256 permitAmount;\n        PermitSignature signature;\n    }\n\n    /**\n     * @notice Struct for the parameters of the ERC721 permit\n     */\n    struct ERC721PermitParams {\n        uint256 tokenId;\n        PermitSignature signature;\n    }\n\n    /**\n     * @notice Struct for the signature of the permit\n     */\n    struct PermitSignature {\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * @notice Struct for the parameters of the open book action\n     */\n    struct OpenBookParams {\n        IBookManager.BookKey key;\n        bytes hookData;\n    }\n\n    /**\n     * @notice Struct for the parameters of the make order action\n     */\n    struct MakeOrderParams {\n        BookId id;\n        Tick tick;\n        uint256 quoteAmount;\n        bytes hookData;\n    }\n\n    /**\n     * @notice Struct for the parameters of the limit order action\n     */\n    struct LimitOrderParams {\n        BookId takeBookId;\n        BookId makeBookId;\n        uint256 limitPrice;\n        Tick tick;\n        uint256 quoteAmount;\n        bytes takeHookData;\n        bytes makeHookData;\n    }\n\n    /**\n     * @notice Struct for the parameters of the take order action\n     */\n    struct TakeOrderParams {\n        BookId id;\n        uint256 limitPrice;\n        uint256 quoteAmount;\n        uint256 maxBaseAmount;\n        bytes hookData;\n    }\n\n    /**\n     * @notice Struct for the parameters of the spend order action\n     */\n    struct SpendOrderParams {\n        BookId id;\n        uint256 limitPrice;\n        uint256 baseAmount;\n        uint256 minQuoteAmount;\n        bytes hookData;\n    }\n\n    /**\n     * @notice Struct for the parameters of the claim order action\n     */\n    struct ClaimOrderParams {\n        OrderId id;\n        bytes hookData;\n    }\n\n    /**\n     * @notice Struct for the parameters of the cancel order action\n     */\n    struct CancelOrderParams {\n        OrderId id;\n        uint256 leftQuoteAmount;\n        bytes hookData;\n    }\n\n    /**\n     * @notice Opens a book\n     * @param openBookParamsList The parameters of the open book action\n     * @param deadline The deadline for the action\n     */\n    function open(OpenBookParams[] calldata openBookParamsList, uint64 deadline) external;\n\n    /**\n     * @notice Returns the depth of a book\n     * @param id The id of the book\n     * @param tick The tick of the book\n     * @return The depth of the book in quote amount\n     */\n    function getDepth(BookId id, Tick tick) external view returns (uint256);\n\n    /**\n     * @notice Returns the highest price of a book\n     * @param id The id of the book\n     * @return The highest price of the book with 2**96 precision\n     */\n    function getHighestPrice(BookId id) external view returns (uint256);\n\n    /**\n     * @notice Returns the details of an order\n     * @param orderId The id of the order\n     * @return provider The provider of the order\n     * @return price The price of the order with 2**96 precision\n     * @return openAmount The open quote amount of the order\n     * @return claimableAmount The claimable base amount of the order\n     */\n    function getOrder(OrderId orderId)\n        external\n        view\n        returns (address provider, uint256 price, uint256 openAmount, uint256 claimableAmount);\n\n    /**\n     * @notice Converts a price to a tick\n     * @param price The price to convert\n     * @return The tick\n     */\n    function fromPrice(uint256 price) external pure returns (Tick);\n\n    /**\n     * @notice Converts a tick to a price\n     * @param tick The tick to convert\n     * @return The price with 2**96 precision\n     */\n    function toPrice(Tick tick) external pure returns (uint256);\n\n    /**\n     * @notice Executes a list of actions\n     * @dev IMPORTANT: The caller must provide `tokensToSettle` to receive appropriate tokens after execution.\n     * @param actionList The list of actions to execute\n     * @param paramsDataList The parameters of the actions\n     * @param tokensToSettle The tokens to settle\n     * @param erc20PermitParamsList The parameters of the ERC20 permits\n     * @param erc721PermitParamsList The parameters of the ERC721 permits\n     * @param deadline The deadline for the actions\n     * @return ids The ids of the orders\n     */\n    function execute(\n        Action[] calldata actionList,\n        bytes[] calldata paramsDataList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata erc20PermitParamsList,\n        ERC721PermitParams[] calldata erc721PermitParamsList,\n        uint64 deadline\n    ) external payable returns (OrderId[] memory ids);\n\n    /**\n     * @notice Makes a list of orders\n     * @dev IMPORTANT: The caller must provide `tokensToSettle` to receive appropriate tokens after execution.\n     * @param orderParamsList The list of actions to make\n     * @param tokensToSettle The tokens to settle\n     * @param permitParamsList The parameters of the permits\n     * @param deadline The deadline for the actions\n     * @return ids The ids of the orders\n     */\n    function make(\n        MakeOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable returns (OrderId[] memory ids);\n\n    /**\n     * @notice Takes a list of orders\n     * @dev IMPORTANT: The caller must provide `tokensToSettle` to receive appropriate tokens after execution.\n     * @param orderParamsList The list of actions to take\n     * @param tokensToSettle The tokens to settle\n     * @param permitParamsList The parameters of the permits\n     * @param deadline The deadline for the actions\n     */\n    function take(\n        TakeOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable;\n\n    /**\n     * @notice Spends to take a list of orders\n     * @dev IMPORTANT: The caller must provide `tokensToSettle` to receive appropriate tokens after execution.\n     * @param orderParamsList The list of actions to spend\n     * @param tokensToSettle The tokens to settle\n     * @param permitParamsList The parameters of the permits\n     * @param deadline The deadline for the actions\n     */\n    function spend(\n        SpendOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC20PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external payable;\n\n    /**\n     * @notice Claims a list of orders\n     * @dev IMPORTANT: The caller must provide `tokensToSettle` to receive appropriate tokens after execution.\n     * @param orderParamsList The list of actions to claim\n     * @param tokensToSettle The tokens to settle\n     * @param permitParamsList The parameters of the permits\n     * @param deadline The deadline for the actions\n     */\n    function claim(\n        ClaimOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC721PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external;\n\n    /**\n     * @notice Cancels a list of orders\n     * @dev IMPORTANT: The caller must provide `tokensToSettle` to receive appropriate tokens after execution.\n     * @param orderParamsList The list of actions to cancel\n     * @param tokensToSettle The tokens to settle\n     * @param permitParamsList The parameters of the permits\n     * @param deadline The deadline for the actions\n     */\n    function cancel(\n        CancelOrderParams[] calldata orderParamsList,\n        address[] calldata tokensToSettle,\n        ERC721PermitParams[] calldata permitParamsList,\n        uint64 deadline\n    ) external;\n}\n"
    },
    "src/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.24;\n\nabstract contract ReentrancyGuard {\n    // uint256(keccak256(\"ReentrancyGuard\")) - 1\n    uint256 internal constant REENTRANCY_GUARD_SLOT = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4;\n\n    error ReentrancyGuardReentrantCall();\n\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        assembly {\n            // Any calls to nonReentrant after this point will fail\n            tstore(REENTRANCY_GUARD_SLOT, 1)\n        }\n    }\n\n    function _nonReentrantAfter() private {\n        assembly {\n            tstore(REENTRANCY_GUARD_SLOT, 0)\n        }\n    }\n\n    function _reentrancyGuardEntered() internal view returns (bool isEntered) {\n        assembly {\n            isEntered := tload(REENTRANCY_GUARD_SLOT)\n        }\n    }\n}\n"
    },
    "v2-core/interfaces/IBookManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {BookId} from \"../libraries/BookId.sol\";\nimport {Currency} from \"../libraries/Currency.sol\";\nimport {OrderId} from \"../libraries/OrderId.sol\";\nimport {Tick} from \"../libraries/Tick.sol\";\nimport {FeePolicy} from \"../libraries/FeePolicy.sol\";\nimport {IERC721Permit} from \"./IERC721Permit.sol\";\nimport {IHooks} from \"./IHooks.sol\";\n\n/**\n * @title IBookManager\n * @notice The interface for the BookManager contract\n */\ninterface IBookManager is IERC721Metadata, IERC721Permit {\n    error InvalidUnitSize();\n    error InvalidFeePolicy();\n    error InvalidProvider(address provider);\n    error LockedBy(address locker, address hook);\n    error CurrencyNotSettled();\n\n    /**\n     * @notice Event emitted when a new book is opened\n     * @param id The book id\n     * @param base The base currency\n     * @param quote The quote currency\n     * @param unitSize The unit size of the book\n     * @param makerPolicy The maker fee policy\n     * @param takerPolicy The taker fee policy\n     * @param hooks The hooks contract\n     */\n    event Open(\n        BookId indexed id,\n        Currency indexed base,\n        Currency indexed quote,\n        uint64 unitSize,\n        FeePolicy makerPolicy,\n        FeePolicy takerPolicy,\n        IHooks hooks\n    );\n\n    /**\n     * @notice Event emitted when a new order is made\n     * @param bookId The book id\n     * @param user The user address\n     * @param tick The order tick\n     * @param orderIndex The order index\n     * @param unit The order unit\n     * @param provider The provider address\n     */\n    event Make(\n        BookId indexed bookId, address indexed user, Tick tick, uint256 orderIndex, uint64 unit, address provider\n    );\n\n    /**\n     * @notice Event emitted when an order is taken\n     * @param bookId The book id\n     * @param user The user address\n     * @param tick The order tick\n     * @param unit The order unit\n     */\n    event Take(BookId indexed bookId, address indexed user, Tick tick, uint64 unit);\n\n    /**\n     * @notice Event emitted when an order is canceled\n     * @param orderId The order id\n     * @param unit The canceled unit\n     */\n    event Cancel(OrderId indexed orderId, uint64 unit);\n\n    /**\n     * @notice Event emitted when an order is claimed\n     * @param orderId The order id\n     * @param unit The claimed unit\n     */\n    event Claim(OrderId indexed orderId, uint64 unit);\n\n    /**\n     * @notice Event emitted when a provider is whitelisted\n     * @param provider The provider address\n     */\n    event Whitelist(address indexed provider);\n\n    /**\n     * @notice Event emitted when a provider is delisted\n     * @param provider The provider address\n     */\n    event Delist(address indexed provider);\n\n    /**\n     * @notice Event emitted when a provider collects fees\n     * @param provider The provider address\n     * @param recipient The recipient address\n     * @param currency The currency\n     * @param amount The collected amount\n     */\n    event Collect(address indexed provider, address indexed recipient, Currency indexed currency, uint256 amount);\n\n    /**\n     * @notice Event emitted when new default provider is set\n     * @param newDefaultProvider The new default provider address\n     */\n    event SetDefaultProvider(address indexed newDefaultProvider);\n\n    /**\n     * @notice This structure represents a unique identifier for a book in the BookManager.\n     * @param base The base currency of the book\n     * @param unitSize The unit size of the book\n     * @param quote The quote currency of the book\n     * @param makerPolicy The maker fee policy of the book\n     * @param hooks The hooks contract of the book\n     * @param takerPolicy The taker fee policy of the book\n     */\n    struct BookKey {\n        Currency base;\n        uint64 unitSize;\n        Currency quote;\n        FeePolicy makerPolicy;\n        IHooks hooks;\n        FeePolicy takerPolicy;\n    }\n\n    /**\n     * @notice Returns the base URI\n     * @return The base URI\n     */\n    function baseURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the contract URI\n     * @return The contract URI\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the default provider\n     * @return The default provider\n     */\n    function defaultProvider() external view returns (address);\n\n    /**\n     * @notice Returns the total reserves of a given currency\n     * @param currency The currency in question\n     * @return The total reserves amount\n     */\n    function reservesOf(Currency currency) external view returns (uint256);\n\n    /**\n     * @notice Checks if a provider is whitelisted\n     * @param provider The address of the provider\n     * @return True if the provider is whitelisted, false otherwise\n     */\n    function isWhitelisted(address provider) external view returns (bool);\n\n    /**\n     * @notice Verifies if an owner has authorized a spender for a token\n     * @param owner The address of the token owner\n     * @param spender The address of the spender\n     * @param tokenId The token ID\n     */\n    function checkAuthorized(address owner, address spender, uint256 tokenId) external view;\n\n    /**\n     * @notice Calculates the amount owed to a provider in a given currency\n     * @param provider The provider's address\n     * @param currency The currency in question\n     * @return The owed amount\n     */\n    function tokenOwed(address provider, Currency currency) external view returns (uint256);\n\n    /**\n     * @notice Calculates the currency balance changes for a given locker\n     * @param locker The address of the locker\n     * @param currency The currency in question\n     * @return The net change in currency balance\n     */\n    function getCurrencyDelta(address locker, Currency currency) external view returns (int256);\n\n    /**\n     * @notice Retrieves the book key for a given book ID\n     * @param id The book ID\n     * @return The book key\n     */\n    function getBookKey(BookId id) external view returns (BookKey memory);\n\n    /**\n     * @notice This structure represents a current status for an order in the BookManager.\n     * @param provider The provider of the order\n     * @param open The open unit of the order\n     * @param claimable The claimable unit of the order\n     */\n    struct OrderInfo {\n        address provider;\n        uint64 open;\n        uint64 claimable;\n    }\n\n    /**\n     * @notice Provides information about an order\n     * @param id The order ID\n     * @return Order information including provider, open status, and claimable unit\n     */\n    function getOrder(OrderId id) external view returns (OrderInfo memory);\n\n    /**\n     * @notice Retrieves the locker and caller addresses for a given lock\n     * @param i The index of the lock\n     * @return locker The locker's address\n     * @return lockCaller The caller's address\n     */\n    function getLock(uint256 i) external view returns (address locker, address lockCaller);\n\n    /**\n     * @notice Provides the lock data\n     * @return The lock data including necessary numeric values\n     */\n    function getLockData() external view returns (uint128, uint128);\n\n    /**\n     * @notice Returns the depth of a given book ID and tick\n     * @param id The book ID\n     * @param tick The tick\n     * @return The depth of the tick\n     */\n    function getDepth(BookId id, Tick tick) external view returns (uint64);\n\n    /**\n     * @notice Retrieves the highest tick for a given book ID\n     * @param id The book ID\n     * @return tick The highest tick\n     */\n    function getHighest(BookId id) external view returns (Tick tick);\n\n    /**\n     * @notice Finds the maximum tick less than a specified tick in a book\n     * @dev Returns `Tick.wrap(type(int24).min)` if the specified tick is the lowest\n     * @param id The book ID\n     * @param tick The specified tick\n     * @return The next lower tick\n     */\n    function maxLessThan(BookId id, Tick tick) external view returns (Tick);\n\n    /**\n     * @notice Checks if a book is opened\n     * @param id The book ID\n     * @return True if the book is opened, false otherwise\n     */\n    function isOpened(BookId id) external view returns (bool);\n\n    /**\n     * @notice Checks if a book is empty\n     * @param id The book ID\n     * @return True if the book is empty, false otherwise\n     */\n    function isEmpty(BookId id) external view returns (bool);\n\n    /**\n     * @notice Encodes a BookKey into a BookId\n     * @param key The BookKey to encode\n     * @return The encoded BookId\n     */\n    function encodeBookKey(BookKey calldata key) external pure returns (BookId);\n\n    /**\n     * @notice Loads a value from a specific storage slot\n     * @param slot The storage slot\n     * @return The value in the slot\n     */\n    function load(bytes32 slot) external view returns (bytes32);\n\n    /**\n     * @notice Loads a sequence of values starting from a specific slot\n     * @param startSlot The starting slot\n     * @param nSlot The number of slots to load\n     * @return The sequence of values\n     */\n    function load(bytes32 startSlot, uint256 nSlot) external view returns (bytes memory);\n\n    /**\n     * @notice Opens a new book\n     * @param key The book key\n     * @param hookData The hook data\n     */\n    function open(BookKey calldata key, bytes calldata hookData) external;\n\n    /**\n     * @notice Locks a book manager function\n     * @param locker The locker address\n     * @param data The lock data\n     * @return The lock return data\n     */\n    function lock(address locker, bytes calldata data) external returns (bytes memory);\n\n    /**\n     * @notice This structure represents the parameters for making an order.\n     * @param key The book key for the order\n     * @param tick The tick for the order\n     * @param unit The unit for the order. Times key.unitSize to get actual bid amount.\n     * @param provider The provider for the order. The limit order service provider address to collect fees.\n     */\n    struct MakeParams {\n        BookKey key;\n        Tick tick;\n        uint64 unit;\n        address provider;\n    }\n\n    /**\n     * @notice Make a limit order\n     * @param params The order parameters\n     * @param hookData The hook data\n     * @return id The order id. Returns 0 if the order is not settled\n     * @return quoteAmount The amount of quote currency to be paid\n     */\n    function make(MakeParams calldata params, bytes calldata hookData)\n        external\n        returns (OrderId id, uint256 quoteAmount);\n\n    /**\n     * @notice This structure represents the parameters for taking orders in the specified tick.\n     * @param key The book key for the order\n     * @param tick The tick for the order\n     * @param maxUnit The max unit to take\n     */\n    struct TakeParams {\n        BookKey key;\n        Tick tick;\n        uint64 maxUnit;\n    }\n\n    /**\n     * @notice Take a limit order at specific tick\n     * @param params The order parameters\n     * @param hookData The hook data\n     * @return quoteAmount The amount of quote currency to be received\n     * @return baseAmount The amount of base currency to be paid\n     */\n    function take(TakeParams calldata params, bytes calldata hookData)\n        external\n        returns (uint256 quoteAmount, uint256 baseAmount);\n\n    /**\n     * @notice This structure represents the parameters for canceling an order.\n     * @param id The order id for the order\n     * @param toUnit The remaining open unit for the order after cancellation. Must not exceed the current open unit.\n     */\n    struct CancelParams {\n        OrderId id;\n        uint64 toUnit;\n    }\n\n    /**\n     * @notice Cancel a limit order\n     * @param params The order parameters\n     * @param hookData The hook data\n     * @return canceledAmount The amount of quote currency canceled\n     */\n    function cancel(CancelParams calldata params, bytes calldata hookData) external returns (uint256 canceledAmount);\n\n    /**\n     * @notice Claims an order\n     * @param id The order ID\n     * @param hookData The hook data\n     * @return claimedAmount The amount claimed\n     */\n    function claim(OrderId id, bytes calldata hookData) external returns (uint256 claimedAmount);\n\n    /**\n     * @notice Collects fees from a provider\n     * @param recipient The recipient address\n     * @param currency The currency\n     * @return The collected amount\n     */\n    function collect(address recipient, Currency currency) external returns (uint256);\n\n    /**\n     * @notice Withdraws a currency\n     * @param currency The currency\n     * @param to The recipient address\n     * @param amount The amount\n     */\n    function withdraw(Currency currency, address to, uint256 amount) external;\n\n    /**\n     * @notice Settles a currency\n     * @param currency The currency\n     * @return The settled amount\n     */\n    function settle(Currency currency) external payable returns (uint256);\n\n    /**\n     * @notice Whitelists a provider\n     * @param provider The provider address\n     */\n    function whitelist(address provider) external;\n\n    /**\n     * @notice Delists a provider\n     * @param provider The provider address\n     */\n    function delist(address provider) external;\n\n    /**\n     * @notice Sets the default provider\n     * @param newDefaultProvider The new default provider address\n     */\n    function setDefaultProvider(address newDefaultProvider) external;\n}\n"
    },
    "v2-core/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * @title IERC721Permit\n * @notice An interface for the ERC721 permit extension\n */\ninterface IERC721Permit is IERC721 {\n    error InvalidSignature();\n    error PermitExpired();\n\n    /**\n     * @notice The EIP-712 typehash for the permit struct used by the contract\n     */\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /**\n     * @notice The EIP-712 domain separator for this contract\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /**\n     * @notice Approve the spender to transfer the given tokenId\n     * @param spender The address to approve\n     * @param tokenId The tokenId to approve\n     * @param deadline The deadline for the signature\n     * @param v The recovery id of the signature\n     * @param r The r value of the signature\n     * @param s The s value of the signature\n     */\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @notice Get the current nonce for a token\n     * @param tokenId The tokenId to get the nonce for\n     * @return The current nonce\n     */\n    function nonces(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "v2-core/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IBookManager} from \"./IBookManager.sol\";\nimport {OrderId} from \"../libraries/OrderId.sol\";\n\n/**\n * @title IHooks\n * @notice Interface for the hooks contract\n */\ninterface IHooks {\n    /**\n     * @notice Hook called before opening a new book\n     * @param sender The sender of the open transaction\n     * @param key The key of the book being opened\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeOpen(address sender, IBookManager.BookKey calldata key, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after opening a new book\n     * @param sender The sender of the open transaction\n     * @param key The key of the book being opened\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterOpen(address sender, IBookManager.BookKey calldata key, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called before making a new order\n     * @param sender The sender of the make transaction\n     * @param params The parameters of the make transaction\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeMake(address sender, IBookManager.MakeParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after making a new order\n     * @param sender The sender of the make transaction\n     * @param params The parameters of the make transaction\n     * @param orderId The id of the order that was made\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterMake(\n        address sender,\n        IBookManager.MakeParams calldata params,\n        OrderId orderId,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Hook called before taking an order\n     * @param sender The sender of the take transaction\n     * @param params The parameters of the take transaction\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeTake(address sender, IBookManager.TakeParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after taking an order\n     * @param sender The sender of the take transaction\n     * @param params The parameters of the take transaction\n     * @param takenUnit The unit that was taken\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterTake(\n        address sender,\n        IBookManager.TakeParams calldata params,\n        uint64 takenUnit,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Hook called before canceling an order\n     * @param sender The sender of the cancel transaction\n     * @param params The parameters of the cancel transaction\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeCancel(address sender, IBookManager.CancelParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after canceling an order\n     * @param sender The sender of the cancel transaction\n     * @param params The parameters of the cancel transaction\n     * @param canceledUnit The unit that was canceled\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterCancel(\n        address sender,\n        IBookManager.CancelParams calldata params,\n        uint64 canceledUnit,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Hook called before claiming an order\n     * @param sender The sender of the claim transaction\n     * @param orderId The id of the order being claimed\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeClaim(address sender, OrderId orderId, bytes calldata hookData) external returns (bytes4);\n\n    /**\n     * @notice Hook called after claiming an order\n     * @param sender The sender of the claim transaction\n     * @param orderId The id of the order being claimed\n     * @param claimedUnit The unit that was claimed\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterClaim(address sender, OrderId orderId, uint64 claimedUnit, bytes calldata hookData)\n        external\n        returns (bytes4);\n}\n"
    },
    "v2-core/interfaces/ILocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ILocker\n * @notice Interface for the locker contract\n */\ninterface ILocker {\n    /**\n     * @notice Called by the book manager on `msg.sender` when a lock is acquired\n     * @param data The data that was passed to the call to lock\n     * @return Any data that you want to be returned from the lock call\n     */\n    function lockAcquired(address lockCaller, bytes calldata data) external returns (bytes memory);\n}\n"
    },
    "v2-core/libraries/BookId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {IBookManager} from \"../interfaces/IBookManager.sol\";\n\ntype BookId is uint192;\n\nlibrary BookIdLibrary {\n    function toId(IBookManager.BookKey memory bookKey) internal pure returns (BookId id) {\n        bytes32 hash = keccak256(abi.encode(bookKey));\n        assembly {\n            id := hash\n        }\n    }\n}\n"
    },
    "v2-core/libraries/Currency.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ntype Currency is address;\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Thrown when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // implementation from\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\n\n        bool success;\n        if (currency.isNative()) {\n            assembly {\n                // Transfer the ETH and store if it succeeded or not.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n\n            if (!success) revert NativeTransferFailed();\n        } else {\n            assembly {\n                // Get a pointer to some free memory.\n                let freeMemoryPointer := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, freeMemoryPointer, 68, 0, 32)\n                    )\n            }\n\n            if (!success) revert ERC20TransferFailed();\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) return address(this).balance;\n        else return IERC20(Currency.unwrap(currency)).balanceOf(address(this));\n    }\n\n    function equals(Currency currency, Currency other) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(other);\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "v2-core/libraries/FeePolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./Math.sol\";\n\ntype FeePolicy is uint24;\n\nlibrary FeePolicyLibrary {\n    uint256 internal constant RATE_PRECISION = 10 ** 6;\n    int256 internal constant MAX_FEE_RATE = 500000;\n    int256 internal constant MIN_FEE_RATE = -500000;\n\n    uint256 internal constant RATE_MASK = 0x7fffff; // 23 bits\n\n    error InvalidFeePolicy();\n\n    function encode(bool usesQuote_, int24 rate_) internal pure returns (FeePolicy feePolicy) {\n        if (rate_ > MAX_FEE_RATE || rate_ < MIN_FEE_RATE) {\n            revert InvalidFeePolicy();\n        }\n\n        uint256 mask = usesQuote_ ? 1 << 23 : 0;\n        assembly {\n            feePolicy := or(mask, add(rate_, MAX_FEE_RATE))\n        }\n    }\n\n    function isValid(FeePolicy self) internal pure returns (bool) {\n        int24 r = rate(self);\n\n        return !(r > MAX_FEE_RATE || r < MIN_FEE_RATE);\n    }\n\n    function usesQuote(FeePolicy self) internal pure returns (bool f) {\n        assembly {\n            f := shr(23, self)\n        }\n    }\n\n    function rate(FeePolicy self) internal pure returns (int24 r) {\n        assembly {\n            r := sub(and(self, RATE_MASK), MAX_FEE_RATE)\n        }\n    }\n\n    function calculateFee(FeePolicy self, uint256 amount, bool reverseRounding) internal pure returns (int256 fee) {\n        int24 r = rate(self);\n\n        bool positive = r > 0;\n        uint256 absRate;\n        unchecked {\n            absRate = uint256(uint24(positive ? r : -r));\n        }\n        // @dev absFee must be less than type(int256).max\n        uint256 absFee = Math.divide(amount * absRate, RATE_PRECISION, reverseRounding ? !positive : positive);\n        fee = positive ? int256(absFee) : -int256(absFee);\n    }\n\n    function calculateOriginalAmount(FeePolicy self, uint256 amount, bool reverseFee)\n        internal\n        pure\n        returns (uint256 originalAmount)\n    {\n        int24 r = rate(self);\n\n        bool positive = r > 0;\n        uint256 divider;\n        assembly {\n            if reverseFee { r := sub(0, r) }\n            divider := add(RATE_PRECISION, r)\n        }\n        originalAmount = Math.divide(amount * RATE_PRECISION, divider, positive);\n    }\n}\n"
    },
    "v2-core/libraries/Lockers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.23;\n\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @author Clober\n/// @author Modified from Uniswap V4 (https://github.com/Uniswap/v4-core/tree/98680ebc1a654120e995d53a5b10ec6fe153066f)\n/// @notice Contains data about pool lockers.\n\n/// @dev This library manages a custom storage implementation for a queue\n///      that tracks current lockers. The \"sentinel\" storage slot for this data structure,\n///      always passed in as IPoolManager.LockData storage self, stores not just the current\n///      length of the queue but also the global count of non-zero deltas across all lockers.\n///      The values of the data structure start at OFFSET, and each value is a locker address.\nlibrary Lockers {\n    /// struct LockData {\n    ///     /// @notice The current number of active lockers\n    ///     uint128 length;\n    ///     /// @notice The total number of nonzero deltas over all active + completed lockers\n    ///     uint128 nonzeroDeltaCount;\n    /// }\n    // uint256(keccak256(\"LockData\")) + 1\n    uint256 internal constant LOCK_DATA_SLOT = 0x760a9a962ae3d184e99c0483cf5684fb3170f47116ca4f445c50209da4f4f907;\n\n    // uint256(keccak256(\"Lockers\")) + 1\n    uint256 internal constant LOCKERS_SLOT = 0x722b431450ce53c44434ec138439e45a0639fe031b803ee019b776fae5cfa2b1;\n\n    // The number of slots per item in the lockers array\n    uint256 internal constant LOCKER_STRUCT_SIZE = 2;\n\n    // uint256(keccak256(\"HookAddress\")) + 1\n    uint256 internal constant HOOK_ADDRESS_SLOT = 0xfcac7593714b88fec0c578a53e9f3f6e4b47eb26c9dcaa7eff23a3ac156be422;\n\n    uint256 internal constant NONZERO_DELTA_COUNT_OFFSET = 2 ** 128;\n\n    uint256 internal constant LENGTH_MASK = (1 << 128) - 1;\n\n    /// @dev Pushes a locker onto the end of the queue, and updates the sentinel storage slot.\n    function push(address locker, address lockCaller) internal {\n        assembly {\n            let data := tload(LOCK_DATA_SLOT)\n            let l := and(data, LENGTH_MASK)\n\n            // LOCKERS_SLOT + l * LOCKER_STRUCT_SIZE\n            let indexToWrite := add(LOCKERS_SLOT, mul(l, LOCKER_STRUCT_SIZE))\n\n            // in the next storage slot, write the locker and lockCaller\n            tstore(indexToWrite, locker)\n            tstore(add(indexToWrite, 1), lockCaller)\n\n            // increase the length\n            tstore(LOCK_DATA_SLOT, add(data, 1))\n        }\n    }\n\n    function lockData() internal view returns (uint128 l, uint128 nonzeroDeltaCount) {\n        assembly {\n            l := tload(LOCK_DATA_SLOT)\n            nonzeroDeltaCount := shr(128, l)\n        }\n    }\n\n    function length() internal view returns (uint128 l) {\n        assembly {\n            l := tload(LOCK_DATA_SLOT)\n        }\n    }\n\n    /// @dev Pops a locker off the end of the queue. Note that no storage gets cleared.\n    function pop() internal {\n        assembly {\n            let data := tload(LOCK_DATA_SLOT)\n            let l := and(data, LENGTH_MASK)\n            if iszero(l) {\n                mstore(0x00, 0xf1c77ed0) // LockersPopFailed()\n                revert(0x1c, 0x04)\n            }\n\n            // LOCKERS_SLOT + (l - 1) * LOCKER_STRUCT_SIZE\n            let indexToWrite := add(LOCKERS_SLOT, mul(sub(l, 1), LOCKER_STRUCT_SIZE))\n\n            // in the next storage slot, delete the locker and lockCaller\n            tstore(indexToWrite, 0)\n            tstore(add(indexToWrite, 1), 0)\n\n            // decrease the length\n            tstore(LOCK_DATA_SLOT, sub(data, 1))\n        }\n    }\n\n    function getLocker(uint256 i) internal view returns (address locker) {\n        assembly {\n            // LOCKERS_SLOT + (i * LOCKER_STRUCT_SIZE)\n            locker := tload(add(LOCKERS_SLOT, mul(i, LOCKER_STRUCT_SIZE)))\n        }\n    }\n\n    function getLockCaller(uint256 i) internal view returns (address locker) {\n        assembly {\n            // LOCKERS_SLOT + (i * LOCKER_STRUCT_SIZE + 1)\n            locker := tload(add(LOCKERS_SLOT, add(mul(i, LOCKER_STRUCT_SIZE), 1)))\n        }\n    }\n\n    function getCurrentLocker() internal view returns (address) {\n        unchecked {\n            uint256 l = length();\n            return l > 0 ? getLocker(l - 1) : address(0);\n        }\n    }\n\n    function getCurrentLockCaller() internal view returns (address) {\n        unchecked {\n            uint256 l = length();\n            return l > 0 ? getLockCaller(l - 1) : address(0);\n        }\n    }\n\n    function incrementNonzeroDeltaCount() internal {\n        assembly {\n            tstore(LOCK_DATA_SLOT, add(tload(LOCK_DATA_SLOT), NONZERO_DELTA_COUNT_OFFSET))\n        }\n    }\n\n    function decrementNonzeroDeltaCount() internal {\n        assembly {\n            tstore(LOCK_DATA_SLOT, sub(tload(LOCK_DATA_SLOT), NONZERO_DELTA_COUNT_OFFSET))\n        }\n    }\n\n    function getCurrentHook() internal view returns (IHooks currentHook) {\n        return IHooks(getHook(length()));\n    }\n\n    function getHook(uint256 i) internal view returns (address hook) {\n        assembly {\n            hook := tload(add(HOOK_ADDRESS_SLOT, i))\n        }\n    }\n\n    function setCurrentHook(IHooks currentHook) internal returns (bool set) {\n        // Set the hook address for the current locker if the address is 0.\n        // If the address is nonzero, a hook has already been set for this lock, and is not allowed to be updated or cleared at the end of the call.\n        if (address(getCurrentHook()) == address(0)) {\n            uint256 l = length();\n            assembly {\n                tstore(add(HOOK_ADDRESS_SLOT, l), currentHook)\n            }\n            return true;\n        }\n    }\n\n    function clearCurrentHook() internal {\n        uint256 l = length();\n        assembly {\n            tstore(add(HOOK_ADDRESS_SLOT, l), 0)\n        }\n    }\n}\n"
    },
    "v2-core/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n    function divide(uint256 a, uint256 b, bool roundingUp) internal pure returns (uint256 ret) {\n        // In the OrderBook contract code, b is never zero.\n        assembly {\n            ret := add(div(a, b), and(gt(mod(a, b), 0), roundingUp))\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                    sar(96, mul(add(24828157081833163892658089445524,\n                        sar(96, mul(add(3273285459638523848632254066296,\n                            x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Base conversion: mul `2**96 / (5**18 * 2**192)`.\n            r := sdiv(p, 302231454903657293676544000000000000000000)\n        }\n    }\n}\n"
    },
    "v2-core/libraries/OrderId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Tick} from \"./Tick.sol\";\nimport {BookId} from \"./BookId.sol\";\n\ntype OrderId is uint256;\n\nlibrary OrderIdLibrary {\n    /**\n     * @dev Encode the order id.\n     * @param bookId The book id.\n     * @param tick The tick.\n     * @param index The index.\n     * @return id The order id.\n     */\n    function encode(BookId bookId, Tick tick, uint40 index) internal pure returns (OrderId id) {\n        // @dev If we just use tick at the assembly code, the code will convert tick into bytes32.\n        //      e.g. When index == -2, the shifted value( shl(40, tick) ) will be\n        //      0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0000000000 instead of 0xfffffffe0000000000\n        //      Therefore, we have to safely cast tick into uint256 first.\n        uint256 _tick = uint256(uint24(Tick.unwrap(tick)));\n        assembly {\n            id := add(index, add(shl(40, _tick), shl(64, bookId)))\n        }\n    }\n\n    function decode(OrderId id) internal pure returns (BookId bookId, Tick tick, uint40 index) {\n        assembly {\n            bookId := shr(64, id)\n            tick := shr(40, id)\n            index := id\n        }\n    }\n\n    function getBookId(OrderId id) internal pure returns (BookId bookId) {\n        assembly {\n            bookId := shr(64, id)\n        }\n    }\n\n    function getTick(OrderId id) internal pure returns (Tick tick) {\n        assembly {\n            tick := shr(40, id)\n        }\n    }\n\n    function getIndex(OrderId id) internal pure returns (uint40 index) {\n        assembly {\n            index := id\n        }\n    }\n}\n"
    },
    "v2-core/libraries/SignificantBit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nlibrary SignificantBit {\n    // http://supertech.csail.mit.edu/papers/debruijn.pdf\n    uint256 internal constant DEBRUIJN_SEQ = 0x818283848586878898A8B8C8D8E8F929395969799A9B9D9E9FAAEB6BEDEEFF;\n    bytes internal constant DEBRUIJN_INDEX =\n        hex\"0001020903110a19042112290b311a3905412245134d2a550c5d32651b6d3a7506264262237d468514804e8d2b95569d0d495ea533a966b11c886eb93bc176c9071727374353637324837e9b47af86c7155181ad4fd18ed32c9096db57d59ee30e2e4a6a5f92a6be3498aae067ddb2eb1d5989b56fd7baf33ca0c2ee77e5caf7ff0810182028303840444c545c646c7425617c847f8c949c48a4a8b087b8c0c816365272829aaec650acd0d28fdad4e22d6991bd97dfdcea58b4d6f29fede4f6fe0f1f2f3f4b5b6b607b8b93a3a7b7bf357199c5abcfd9e168bcdee9b3f1ecf5fd1e3e5a7a8aa2b670c4ced8bbe8f0f4fc3d79a1c3cde7effb78cce6facbf9f8\";\n\n    /**\n     * @notice Finds the index of the least significant bit.\n     * @param x The value to compute the least significant bit for. Must be a non-zero value.\n     * @return ret The index of the least significant bit.\n     */\n    function leastSignificantBit(uint256 x) internal pure returns (uint8) {\n        require(x > 0);\n        uint256 index;\n        assembly {\n            index := shr(248, mul(and(x, add(not(x), 1)), DEBRUIJN_SEQ))\n        }\n        return uint8(DEBRUIJN_INDEX[index]); // can optimize with CODECOPY opcode\n    }\n\n    function mostSignificantBit(uint256 x) internal pure returns (uint8) {\n        require(x > 0);\n        uint256 msb;\n        assembly {\n            let f := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := shl(5, gt(x, 0xFFFFFFFF))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := shl(4, gt(x, 0xFFFF))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := shl(3, gt(x, 0xFF))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := shl(2, gt(x, 0xF))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := shl(1, gt(x, 0x3))\n            msb := or(msb, f)\n            x := shr(f, x)\n            f := gt(x, 0x1)\n            msb := or(msb, f)\n        }\n        return uint8(msb);\n    }\n}\n"
    },
    "v2-core/libraries/Tick.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./Math.sol\";\n\ntype Tick is int24;\n\nlibrary TickLibrary {\n    using Math for *;\n    using TickLibrary for Tick;\n\n    error InvalidTick();\n    error InvalidPrice();\n    error TickOverflow();\n\n    int24 internal constant MAX_TICK = 2 ** 19 - 1;\n    int24 internal constant MIN_TICK = -MAX_TICK;\n\n    uint256 internal constant MIN_PRICE = 1350587;\n    uint256 internal constant MAX_PRICE = 4647684107270898330752324302845848816923571339324334;\n\n    uint256 private constant _R0 = 0xfff97272373d413259a46990;\n    uint256 private constant _R1 = 0xfff2e50f5f656932ef12357c;\n    uint256 private constant _R2 = 0xffe5caca7e10e4e61c3624ea;\n    uint256 private constant _R3 = 0xffcb9843d60f6159c9db5883;\n    uint256 private constant _R4 = 0xff973b41fa98c081472e6896;\n    uint256 private constant _R5 = 0xff2ea16466c96a3843ec78b3;\n    uint256 private constant _R6 = 0xfe5dee046a99a2a811c461f1;\n    uint256 private constant _R7 = 0xfcbe86c7900a88aedcffc83b;\n    uint256 private constant _R8 = 0xf987a7253ac413176f2b074c;\n    uint256 private constant _R9 = 0xf3392b0822b70005940c7a39;\n    uint256 private constant _R10 = 0xe7159475a2c29b7443b29c7f;\n    uint256 private constant _R11 = 0xd097f3bdfd2022b8845ad8f7;\n    uint256 private constant _R12 = 0xa9f746462d870fdf8a65dc1f;\n    uint256 private constant _R13 = 0x70d869a156d2a1b890bb3df6;\n    uint256 private constant _R14 = 0x31be135f97d08fd981231505;\n    uint256 private constant _R15 = 0x9aa508b5b7a84e1c677de54;\n    uint256 private constant _R16 = 0x5d6af8dedb81196699c329;\n    uint256 private constant _R17 = 0x2216e584f5fa1ea92604;\n    uint256 private constant _R18 = 0x48a170391f7dc42;\n    uint256 private constant _R19 = 0x149b34;\n\n    function validateTick(Tick tick) internal pure {\n        if (Tick.unwrap(tick) > MAX_TICK || Tick.unwrap(tick) < MIN_TICK) revert InvalidTick();\n    }\n\n    modifier validatePrice(uint256 price) {\n        if (price > MAX_PRICE || price < MIN_PRICE) revert InvalidPrice();\n        _;\n    }\n\n    function fromPrice(uint256 price) internal pure validatePrice(price) returns (Tick) {\n        unchecked {\n            int24 tick = int24((int256(price).lnWad() * 42951820407860) / 2 ** 128);\n            if (toPrice(Tick.wrap(tick)) > price) return Tick.wrap(tick - 1);\n            return Tick.wrap(tick);\n        }\n    }\n\n    function toPrice(Tick tick) internal pure returns (uint256 price) {\n        validateTick(tick);\n        int24 tickValue = Tick.unwrap(tick);\n        uint256 absTick = uint24(tickValue < 0 ? -tickValue : tickValue);\n\n        unchecked {\n            if (absTick & 0x1 != 0) price = _R0;\n            else price = 1 << 96;\n            if (absTick & 0x2 != 0) price = (price * _R1) >> 96;\n            if (absTick & 0x4 != 0) price = (price * _R2) >> 96;\n            if (absTick & 0x8 != 0) price = (price * _R3) >> 96;\n            if (absTick & 0x10 != 0) price = (price * _R4) >> 96;\n            if (absTick & 0x20 != 0) price = (price * _R5) >> 96;\n            if (absTick & 0x40 != 0) price = (price * _R6) >> 96;\n            if (absTick & 0x80 != 0) price = (price * _R7) >> 96;\n            if (absTick & 0x100 != 0) price = (price * _R8) >> 96;\n            if (absTick & 0x200 != 0) price = (price * _R9) >> 96;\n            if (absTick & 0x400 != 0) price = (price * _R10) >> 96;\n            if (absTick & 0x800 != 0) price = (price * _R11) >> 96;\n            if (absTick & 0x1000 != 0) price = (price * _R12) >> 96;\n            if (absTick & 0x2000 != 0) price = (price * _R13) >> 96;\n            if (absTick & 0x4000 != 0) price = (price * _R14) >> 96;\n            if (absTick & 0x8000 != 0) price = (price * _R15) >> 96;\n            if (absTick & 0x10000 != 0) price = (price * _R16) >> 96;\n            if (absTick & 0x20000 != 0) price = (price * _R17) >> 96;\n            if (absTick & 0x40000 != 0) price = (price * _R18) >> 96;\n        }\n        if (tickValue > 0) price = 0x1000000000000000000000000000000000000000000000000 / price;\n    }\n\n    function gt(Tick a, Tick b) internal pure returns (bool) {\n        return Tick.unwrap(a) > Tick.unwrap(b);\n    }\n\n    function baseToQuote(Tick tick, uint256 base, bool roundingUp) internal pure returns (uint256) {\n        return Math.divide((base * tick.toPrice()), 1 << 96, roundingUp);\n    }\n\n    function quoteToBase(Tick tick, uint256 quote, bool roundingUp) internal pure returns (uint256) {\n        // @dev quote = unit(uint64) * unitSize(uint64) < 2^96\n        //      We don't need to check overflow here\n        return Math.divide(quote << 96, tick.toPrice(), roundingUp);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}